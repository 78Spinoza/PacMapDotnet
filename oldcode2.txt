  // Normalization Configuration
        println!(" Data Normalization Configuration:");
        println!("   - Mode: {:?}", self.normalization.mode);
        println!("   - Features: {}", self.normalization.n_features);
        match self.normalization.mode {
            crate::stats::NormalizationMode::ZScore => {
                if !self.normalization.means.is_empty() {
                    println!("   - Means: [{:.3}, ..., {:.3}] (length: {})",
                             self.normalization.means[0],
                             self.normalization.means.last().unwrap_or(&0.0),
                             self.normalization.means.len());
                }
                if !self.normalization.stds.is_empty() {
                    println!("   - Std devs: [{:.3}, ..., {:.3}] (length: {})",
                             self.normalization.stds[0],
                             self.normalization.stds.last().unwrap_or(&1.0),
                             self.normalization.stds.len());
                }
            },
            crate::stats::NormalizationMode::MinMax => {
                if !self.normalization.mins.is_empty() {
                    println!("   - Minimums: [{:.3}, ..., {:.3}] (length: {})",
                             self.normalization.mins[0],
                             self.normalization.mins.last().unwrap_or(&0.0),
                             self.normalization.mins.len());
                }
                if !self.normalization.maxs.is_empty() {
                    println!("   - Maximums: [{:.3}, ..., {:.3}] (length: {})",
                             self.normalization.maxs[0],
                             self.normalization.maxs.last().unwrap_or(&1.0),
                             self.normalization.maxs.len());
                }
            },
            crate::stats::NormalizationMode::Robust => {
                if !self.normalization.medians.is_empty() {
                    println!("   - Medians: [{:.3}, ..., {:.3}] (length: {})",
                             self.normalization.medians[0],
                             self.normalization.medians.last().unwrap_or(&0.0),
                             self.normalization.medians.len());
                }
                if !self.normalization.iqrs.is_empty() {
                    println!("   - IQRs: [{:.3}, ..., {:.3}] (length: {})",
                             self.normalization.iqrs[0],
                             self.normalization.iqrs.last().unwrap_or(&1.0),
                             self.normalization.iqrs.len());
                }
            },
            _ => {}
        }

        println!();

        // Embedding Information
        println!(" Embedding Information:");
        println!("   - Shape: {:?}", self.embedding.shape());
        let non_zero_count = self.embedding.iter().filter(|&&x| x.abs() > 1e-10).count();
        println!("   - Non-zero values: {}/{} ({:.1}%)",
                 non_zero_count, self.embedding.len(),
                 (non_zero_count as f64 / self.embedding.len() as f64) * 100.0);

        println!();

        // Distance Statistics
        println!("Distance Statistics:");
        println!("   - Mean distance: {:.6}", self.stats.mean_distance);
        println!("   - 95th percentile: {:.6}", self.stats.p95_distance);
        println!("   - Maximum distance: {:.6}", self.stats.max_distance);

        println!();

        // Quantization Information
        if self.quantize_on_save {
            println!("  Quantization Configuration:");
            println!("   - Quantize on save: Enabled");
            if let Some(ref quantized) = self.quantized_embedding {
                println!("   - Quantized shape: {:?}", quantized.data.shape());
                println!("   - Min value: {:.6}", quantized.params.min_value);
                println!("   - Max value: {:.6}", quantized.params.max_value);
                println!("   - Scale factor: {:.6}", quantized.params.scale);
                println!("   - Zero point: {}", quantized.params.zero_point);
                if let Some(ref centroids) = quantized.params.centroids {
                    if !centroids.is_empty() {
                        println!("   - Centroids: {} values", centroids.len());
                    }
                } else {
                    println!("   - Centroids: None");
                }
            } else {
                println!("   - Quantized embedding: Not yet computed");
            }
        } else {
            println!("  Quantization: Disabled (full precision preserved)");
        }

        println!();
        println!("===========================================");
        println!();
    }
}

impl Clone for PaCMAP {
    fn clone(&self) -> Self {
        Self {
            embedding: self.embedding.clone(),
            config: self.config.clone(),
            stats: self.stats.clone(),
            normalization: self.normalization.clone(),
            quantize_on_save: self.quantize_on_save,
            quantized_embedding: self.quantized_embedding.clone(),
            original_data: self.original_data.clone(),
            fitted_projections: self.fitted_projections.clone(),
            embedding_centroid: self.embedding_centroid.clone(),
            #[cfg(feature = "use_hnsw")]
            hnsw_index: None, // Don't clone HNSW indices - they'll be rebuilt on demand
            #[cfg(feature = "use_hnsw")]
            embedding_hnsw_index: None,
            serialized_hnsw_index: self.serialized_hnsw_index.clone(),
            // REMOVED: Never save transformed space HNSW index
            // serialized_embedding_hnsw_index: self.serialized_embedding_hnsw_index.clone(), // REMOVED
            hnsw_index_crc32: self.hnsw_index_crc32,
            fitted_projections_crc32: self.fitted_projections_crc32,
        }
    }
}

/// Create serialized HNSW index using binary MessagePack format (much faster than JSON)
#[cfg(feature = "use_hnsw")]
pub fn custom_serialize_hnsw(data: &Array2<f64>, hnsw_params: &HnswParams, max_layer: usize) -> Result<SerializableHnswIndex, Box<dyn std::error::Error>> {
    let data_f32: Vec<Vec<f32>> = data.rows()
        .into_iter()
        .map(|row| row.iter().map(|&x| x as f32).collect())
        .collect();

    let serializable = SerializableHnswIndex {
        data: data_f32,
        params: hnsw_params.clone(),
        max_layer,
    };

    Ok(serializable)
}

/// Serialize SerializableHnswIndex to binary bytes using MessagePack
pub fn serialize_hnsw_to_bytes(serializable_index: &SerializableHnswIndex) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    let serialized_bytes = rmp_serde::to_vec(serializable_index)?;
    Ok(serialized_bytes)
}

/// Deserialize SerializableHnswIndex from binary bytes using MessagePack
pub fn deserialize_hnsw_from_bytes(serialized_bytes: &[u8]) -> Result<SerializableHnswIndex, Box<dyn std::error::Error>> {
    let serializable_index: SerializableHnswIndex = rmp_serde::from_slice(serialized_bytes)?;
    Ok(serializable_index)
}

/// Load HNSW from serialized index (used by transform functions)
#[cfg(feature = "use_hnsw")]
pub fn load_hnsw_from_serialized(serialized_index: &SerializableHnswIndex) -> Result<Hnsw<'_, f32, DistL2>, Box<dyn std::error::Error>> {
    let n_samples = serialized_index.data.len();

    let hnsw = Hnsw::<f32, DistL2>::new(
        serialized_index.params.m,
        n_samples,
        serialized_index.max_layer,
        serialized_index.params.ef_construction,
        DistL2{}
    );

    // Insert all data points
    for (i, point) in serialized_index.data.iter().enumerate() {
        hnsw.insert((point, i));
    }

    Ok(hnsw)
}